#### Задание

Пишем скрипт «сервер» используя модуль socket. Вся программа должна уметь конфигурироваться с помощью модуля argparse. Порт и адрес в том числе должны конфигурироваться с помощью argparse. Это значит, я могу написать

```python3 your_program.py --host 127.0.0.1 --port 8888```

и она запустится именно на этих параметрах

Добавьте во все необязательные аргументы разумные умолчания.

Сервер будет принимать запросы от браузера. Не запутайся в IP. Если у тебя код работает в виртуалке, а браузер в основной OS, то сервер должен запускаться на том IP который прописан у виртуалки.

И так, сервер принимает запрос передает его в метод process_request из твоего модуля отвечающего за обработку http соединений.

Метод process_request вернет какие-то нужные данные для метода run из твоего модуля backend

Метод run будет инициировать ту часть требований которая относится к бэкенду. Вернет он какие-то данные для метода process_response, который реализует http ответ клиенту.

Прочти предыдущий абзац еще раз. Теперь ты понял концепт как будет выглядеть твоя программа целиком.

Далее я буду использовать слово «программа», а ты решай, в каком месте твоей программы будут реализованы требования.

#### Требования:

Если программа получила не http запрос, то надо выбросить исключение работы с сетью. И с соответствующим сообщением завершить работу полностью.

Программа должна получать из запроса: http метод, url и куки

Если http метод не GET/POST то надо отдать клиенту нормальный ответ с HTML документом, в котором, в теле, будет написано что программа принимает только GET/POST и пост запросы.

Все! запросы пишутся в access лог, в файл. Лог должен быть двух видов:

полный, когда запрос логируется целиком

сокращенный, когда логируется только http метод, url и куки используй декораторы с умом. По умолчанию пишется полный лог.

Если пришел POST запрос /short_log/1, то программа где-то должна себе пометить что все последующие запросы логируются в сокращенном виде.

Все! ошибки логируются в error лог. А клиенту отдается ответ с нужным http кодом и HTML телом в котором написано, что-то внятное. Если где-то у программы включена опция show_errors, то в тело также передается оригинальное сообщение отловленной ошибки.

Запрос /showerrors/1 должен включать опцию show_errors

Запрос /show_errors/0 должен выключать эту опцию

Если пришел GET запрос /div/<любозначение1>/to/<любозначение2>, то программа делит то что будет передано в <любозначение1> на то что будет передано в <любое_значение2>

Если пришел запрос /set_cookie/=/, то программа добавляет соответствующие = куки в ответ. Надо выбрасывать какое-то исключение если передано что-то корявое и куки из этого построить не получится.

Если программа в запросах получает куки bg_color=green, то все HTML документы которые программа отдает клиенту должны иметь зеленый бэкграунд. Иначе — белый.

Понятно дело что ответы клиенту должны отдаваться по правилам http протокола, т. е. браузер должен реально обрабатывать ваши данные и адекватно реагировать на полученный ответ.

Запрос на /, т. е. без пути, должен показать страницу на которой будет форма, с помощью которой можно отправлять остальные запросы.

Все прочие GET/POST запросы на любые другие url должны отдавать соответствующую HTTP ошибку.

Вчитывайся, декомпозируй и структурируй то, что описано в требованиях.

#### Лирика:
Ты должен учесть все!!! имена методов, распределение методов по модулям, константы, конфиги. имена переменных, модулей, читаемость кода, обработка ошибок, и всё всё всё. Но только в том случае, если это надо. Излишне показушный код — тоже никому не нужен.

Пришло время писать функции. И модули. Каждый адекватный по объему кусок логики должен быть оформлен как функция. Я говорил, в реальных задачах все пишется в виде функций для каких-то модулей.

Никаких чудодейственным образом появляющихся переменных быть не должно. Чтобы я не бегал по всему файлу и не искал откуда взялась такая-то переменная. Не забывайте что есть *args и **kwargs.

Задание будет оцениваться очень строго. Задание не сложное, акцент надо делать на прозрачность логики, читаемость кода, способность декомпозировать.
Не надо пытаться сдать черти-что, лишь-бы работало. Рабочесть кода — это само-собою разумеется, и этим никого не удивишь.

Если вы получите замечание по не оптимальности решения, то это не страшно. Ибо опыта у вас не много.

Но если вы получите замечание что код плохой, не читаемый, если мы не сможем прочитать его с легкостью и понять какое конкретно решение должен реализовать этот код, то, скорее всего результат будет грустный.

Еще раз, у вас есть какой-то багаж знаний. Теперь надо показать, какой код вы можете предоставить опираясь на эти знания.

Я уверен что вы что-то, да упустите. Но я советую перечитывать задание до тех пор, пока не станет понятно что мы от вас ждем.

Декомпозируй, выписывай.

Ну например не вздумай в месте где требуется HTML документ, отдать просто какую-нибудь строку не обернутую в HTML.

Или не вздумай забыть обработать ситуацию когда программа оживает POST, а получила GET.

Если что-то не понятно, или есть неоднозначность, то задай мне вопрос. Это лучше чем в момент проверки я скажу что «ты не правильно понял, переделай».

Всегда задавай себе вопрос — «а что если»

#### Сдача:
day7/

**Крайний срок** — 04.06.2019 23:59:59 МСК. Любая сдача после этого времени игнорируется.